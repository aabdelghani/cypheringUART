# CypheringUART

A secure ESP32-based UART communication system with AES-128 CTR mode encryption for real-time encrypted data transmission between ESP32 devices.

## Overview

CypheringUART implements end-to-end encrypted UART communication using:
- **AES-128 CTR Mode** for symmetric encryption
- **Hardware RNG** for secure nonce generation
- **ESP32/ESP32-S3** microcontrollers
- **Monitoring tools** for debugging and analysis

## Features

- ✅ **Real-time Encryption**: AES-128 CTR mode for secure data transmission
- ✅ **Hardware Security**: ESP32 hardware RNG for cryptographically secure nonces
- ✅ **Automatic Packet Structure**: `[NONCE(16 bytes)][ENCRYPTED_DATA]`
- ✅ **Monitoring Tools**: Python and C-based UART sniffers with decryption
- ✅ **Cross-Device Compatible**: Works between ESP32 and ESP32-S3
- ✅ **Low Latency**: Optimized for real-time communication at 115200 baud

## Architecture

```
┌─────────────────┐                    ┌─────────────────┐
│  ESP32 Sender   │                    │ ESP32-S3 Receiver│
│                 │                    │                 │
│  ┌───────────┐  │                    │  ┌───────────┐  │
│  │ Plaintext │  │                    │  │ Encrypted │  │
│  │   Data    │  │                    │  │   Data    │  │
│  └─────┬─────┘  │                    │  └─────┬─────┘  │
│        │        │                    │        │        │
│        ▼        │                    │        ▼        │
│  ┌───────────┐  │   UART (115200)    │  ┌───────────┐  │
│  │ AES-128   │  │   GPIO 17 → 16     │  │ AES-128   │  │
│  │ CTR Mode  │  ├────────────────────┤  │ CTR Mode  │  │
│  │ Encrypt   │  │   [NONCE][DATA]    │  │ Decrypt   │  │
│  └───────────┘  │                    │  └───────────┘  │
│                 │                    │                 │
└─────────────────┘                    └─────────────────┘
```

## Project Structure

```
cypheringUART/
├── sender/                    # ESP32 sender firmware
│   ├── main/
│   │   ├── main.c            # Main sender application
│   │   ├── aes_wrapper.c     # AES encryption wrapper
│   │   └── aes_wrapper.h     # AES API definitions
│   ├── CMakeLists.txt
│   └── README.md
│
├── reciever/                 # ESP32-S3 receiver firmware
│   ├── main/
│   │   ├── main.c            # Main receiver application
│   │   ├── aes_wrapper.c     # AES decryption wrapper
│   │   └── aes_wrapper.h     # AES API definitions
│   ├── CMakeLists.txt
│   └── README.md
│
├── tiny-AES-c/               # AES library (submodule)
│
├── uart_sniffer.py           # Python UART monitor
├── decrypt_sniffer.py        # Python UART decryption tool
├── uart_decrypt_sniffer.c    # C-based UART decryption tool
├── sniff_uart.sh             # UART sniffing script
├── Makefile                  # Build for C sniffer
│
└── README.md                 # This file
```

## Quick Start

### Prerequisites

- **ESP-IDF**: v5.5.2 or later
- **Python 3**: For monitoring tools
- **ESP32/ESP32-S3**: Development boards
- **UART Connection**: USB-to-Serial adapter or direct UART connection

### 1. Clone Repository

```bash
git clone --recursive https://github.com/aabdelghani/cypheringUART.git
cd cypheringUART
```

### 2. Setup ESP-IDF

```bash
. $HOME/esp/esp-idf/export.sh
```

### 3. Build and Flash Sender

```bash
cd sender
idf.py build
idf.py -p /dev/ttyUSB0 flash monitor
```

### 4. Build and Flash Receiver

```bash
cd reciever
idf.py set-target esp32s3
idf.py build
idf.py -p /dev/ttyACM0 flash monitor
```

## Hardware Setup

### UART Wiring

Connect sender and receiver ESP32 devices:

```
Sender ESP32      →    Receiver ESP32-S3
─────────────────────────────────────────
GPIO 17 (TX)      →    GPIO 16 (RX)
GPIO 16 (RX)      ←    GPIO 17 (TX)  [optional]
GND               →    GND
```

### Pin Configuration

**Sender (ESP32):**
- TX: GPIO 17
- RX: GPIO 16
- UART: UART2
- Baud: 115200

**Receiver (ESP32-S3):**
- RX: GPIO 16
- TX: GPIO 17
- UART: UART2
- Baud: 115200

## Monitoring Tools

### Python UART Sniffer

Monitor raw UART traffic:

```bash
./uart_sniffer.py /dev/ttyUSB0 115200
```

### Python Decrypt Sniffer

Monitor and decrypt UART traffic in real-time:

```bash
./decrypt_sniffer.py /dev/ttyUSB0 115200
```

### C UART Decrypt Sniffer

High-performance C-based monitoring tool:

```bash
make
./uart_decrypt_sniffer /dev/ttyUSB0
```

### Shell Script Wrapper

```bash
./sniff_uart.sh /dev/ttyUSB0
```

## Security

### Encryption Details

- **Algorithm**: AES-128
- **Mode**: CTR (Counter Mode)
- **Key Size**: 128 bits (16 bytes)
- **Nonce Size**: 128 bits (16 bytes)
- **Nonce Generation**: ESP32 Hardware RNG

### Packet Format

```
[NONCE (16 bytes)][ENCRYPTED DATA (variable length)]
```

Each transmission includes:
1. **Nonce**: 16 random bytes generated by ESP32 hardware RNG
2. **Encrypted Data**: AES-128 CTR encrypted payload

### Key Management

⚠️ **Important**: Currently uses a hardcoded pre-shared key for demonstration purposes.

**For Production:**
- Store keys in ESP32 NVS encrypted partition
- Implement secure key exchange protocol
- Use ESP32 secure boot and flash encryption
- Consider key rotation mechanisms

### Security Considerations

- ✅ Unique nonce per message (critical for CTR mode)
- ✅ Hardware RNG for cryptographic security
- ⚠️ Pre-shared key (suitable for demo/testing)
- ⚠️ No authentication (consider adding HMAC)
- ⚠️ No forward secrecy (consider key rotation)

## Customization

### Change Encryption Key

Edit both `sender/main/main.c` and `reciever/main/main.c`:

```c
static const uint8_t AES_SHARED_KEY[AES_KEY_SIZE] = {
    0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,
    0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c
};
```

### Change UART Configuration

Edit `main.c` in sender or receiver:

```c
#define TXD_PIN (GPIO_NUM_17)
#define RXD_PIN (GPIO_NUM_16)
#define UART_BAUD_RATE 115200
```

### Modify Transmission Interval

Edit `sender/main/main.c`:

```c
vTaskDelay(pdMS_TO_TICKS(5000));  // 5 seconds between messages
```

## API Reference

### AES Wrapper API

```c
// Initialize AES with 128-bit key
void aes_init(const uint8_t *key);

// Encrypt data using AES-128 CTR mode
void aes_encrypt_ctr(const uint8_t *input, uint8_t *output,
                     size_t length, const uint8_t *nonce);

// Decrypt data using AES-128 CTR mode
void aes_decrypt_ctr(const uint8_t *input, uint8_t *output,
                     size_t length, const uint8_t *nonce);

// Generate cryptographically secure random nonce
void aes_generate_nonce(uint8_t *nonce);
```

## Testing

### Test Messages

The sender automatically cycles through test messages:
1. "Hello from ESP32 Sender!"
2. "Secure UART Communication"
3. "AES-128 CTR Mode Active"
4. "Testing encrypted channel..."

### Verify Decryption

Monitor receiver output:

```bash
idf.py -p /dev/ttyACM0 monitor
```

Expected output:
```
========================================
Message #1 successfully decrypted!
========================================
Plaintext message: "Hello from ESP32 Sender!"
Total packet size: 41 bytes (nonce: 16 + data: 25)
========================================
```

## Troubleshooting

| Issue | Solution |
|-------|----------|
| Build errors | Source ESP-IDF environment: `. $HOME/esp/esp-idf/export.sh` |
| Flash errors | Check USB port and permissions: `sudo usermod -a -G dialout $USER` |
| No UART output | Verify wiring: TX→RX crossover, check baud rate |
| Decryption fails | Ensure both devices use identical AES key |
| Garbage output | Check GND connection between devices |
| Permission denied | Add user to dialout group, then logout/login |

## Performance

- **Encryption Speed**: ~1-2ms per message (depends on data size)
- **UART Throughput**: 115200 baud (≈11.5 KB/s)
- **Latency**: <5ms end-to-end (typical)
- **CPU Usage**: Minimal (<5% on ESP32)

## Documentation

- [Sender README](sender/README.md) - Detailed sender documentation
- [Receiver README](reciever/README.md) - Detailed receiver documentation
- [STCom AES Encryption Proposal](STCom_AES_Encryption_Proposal.pdf) - Protocol specification
- [UL1998 Standard](UL1998.pdf) - Safety standard reference

## Dependencies

- **ESP-IDF**: Official ESP32 development framework
- **tiny-AES-c**: Lightweight AES library (included as submodule)
- **FreeRTOS**: Real-time operating system (included in ESP-IDF)

## Contributing

Contributions are welcome! Please:
1. Fork the repository
2. Create a feature branch
3. Commit your changes
4. Submit a pull request

## Future Enhancements

- [ ] Add message authentication (HMAC)
- [ ] Implement secure key exchange (ECDH)
- [ ] Add bidirectional communication
- [ ] Support multiple encryption modes (GCM, CBC)
- [ ] Implement key rotation mechanism
- [ ] Add Wi-Fi configuration interface
- [ ] Create mobile app for monitoring
- [ ] Add OTA firmware updates

## License

This project uses components with various licenses:
- **tiny-AES-c**: Public domain (Unlicense)
- **ESP-IDF**: Apache 2.0
- Project code: [Specify your license]

## Author

Ahmed Abdelghany ([@aabdelghani](https://github.com/aabdelghani))

## Acknowledgments

- [tiny-AES-c](https://github.com/kokke/tiny-AES-c) by kokke for the AES implementation
- Espressif Systems for ESP-IDF framework
- ESP32 community for support and resources

---

**⚠️ Disclaimer**: This project is for educational and prototyping purposes. For production use, implement proper key management, authentication, and security hardening.
